---
title: "DiseaseDiva"
author: "Us"
date: "10/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction 
Prostate cancer is among one of the leading causes of death in males in the United States. The genomic study of metastatic prostate cancer has been limited due to tumor samples being obtained from autopsies as well as limited cohort preclinical models. Prospective studies are few and far between due to limitations in collecting adequate tumor tissue through biopsy. A paper published in 2015 prospectively analyzed tumor biopsies among affected individuals. Subsequently as of 2016, genomic data for prostate cancer has become more widely available due to the National Cancer Institutes (NCI) Genomics Data Commons (GDC).

In this project we will explore data from both the 2015 prospective cohort study along with data available from the NCI's Genomic Data Commons. This project aims to investigate three datasets, through mapping and transformation of the raw data in multiple programs such as Excel, SQL and R,  with the ultimate goal of optimizing downstream analysis of the prostate cancer cohorts. We will discuss various methods by which we wrangled the data to investigate underlying associations between individual case presentations and manifestation of disease.

A team of 73 researchers conducted a multi-institutional study that investigated clinical genomics of advanced prostate cancer specifically metastatic, castration resistant prostate cancer (mCRPC). mCRPC occurs in individuals who develop resistance to androgen deprivation therapies (ADT). The aim of this research was to facilitate precision medicine by developing a prospective whole-exome and transcriptome sequencing of tumor biopsies. Data was obtained from living affected individuals to compile a set of genomic alterations. The study was published in the journal "Cell" in May 2015. 

The link to the publication can be found [here.](https://pubmed.ncbi.nlm.nih.gov/26000489/)

Data was extracted from the cBioPortal, a public cancer genomics site hosted and maintained by the Memorial Sloan Kettering Cancer Center. The sample included 150 individuals with metastatic prostate cancer along with 17 data points per individual,  described below:
-**Patient ID**: unique patient identifier (number)
-**Sample ID**: unique biopsy sample identifier from clinical trial(number)
-**Mutation Count**: mutation rate for mCRPC defined as mutations per megabase or mutations/Mb (number)
-**Fraction Genome Altered**: fraction of mutant allele variants in biopsy (number)
-**Diagnosis Age**: patient's age when they were diagnosed (number)
-**Tumor Site**: physical site of tumor on human body from which biopsy was taken (string)
-**Abiraterzone (ABI) and Enzalutamide (ENZA) Exposure Status**: exposure to  second-generation androgen deprivation therapies (binary: yes/no)
-**Center of Sequencing**: the international academic medical center where exome sequencing occurred (string)
-**Prior Treatment**: receipt of previous androgen deprivation therapy (binary:yes/no)
-**Site Sequenced**: site of exome sequencing: Broad or UM (string)
-**tumor content**: percentage of tumor captured in the biopsy (number)

The National Cancer Institute (NCI) maintains a unified repository of genomic data known as the Genomic Data Commons(GDC). Groundwork for this repository began in June 2015 with nearly 50,000 raw data sequences analyzed by June 2016. This data sharing platform uses an Open-Stack-based private cloud to unite several large-scale cancer genome research programs such as TCGA and OCG. The purpose of this repository is to standardize the data processing of these multi-dimensional datasets by using common bioinformatics pipelines that facilitate direct comparison of the data. 

More about the National Cancer Institute's Genomic Data Commons can be found [here.](https://gdc.cancer.gov/about-gdc)

Data was extracted from GDC Portal's Exploration page. The "cleaned" version of the data sample included 493 individuals with metastatic prostrate cancer along with 24 data points per individual as described below: 
-**CaseUUID**: universally unique identifier assigned to every entity in the data model (string)
-**CaseID**:specific individual cases using the submitter ID from the genomic cancer research program (string)
-**Project**:The cancer research program from which the case originated from (string)
-**Primary Site**: The primary site of the cancer (string)
-**Gender**:"Gender is defined as a set of characteristics that distinguish persons based on their social roles" (string)
-**Files**: the quantity of files available for that case (number)
-**Seq**:Number of the sequencing reads(an inferred sequence of basepairs) (number)
-**Exp**:The transcriptome profiling (number)
-**SNV**:simple nucleotide variation (number)
-**CNV**:Copy number variation,the number of copies of a particular gene varies from one individual to the next (number)
-**Meth**:Number of DNA methylation that took place (number)
-**Clinical**: The number of clinical alterations (number)
-**Bio**:biospecimen (number)
-**Mutations**:The number of simple somatic mutations detected for that case(number)
-**Genes**: The quantity of genes affected by mutations for each case (number)
-**Slides**: the quantity of slides available for each case (number)
-**Program**: The type of program the subject is enrolled in “The Cancer Genome Atlas” or the “Count Me In” (string) 
-**Disease Type**: This describes if it is Adenomas and Adenocarcinomas, the location where the cancer is formed (string)
-**Age at diagnosis**:Age at the time of diagnosis calculated from their day of
birth to the day they were diagnosed with cancer (string)
-**Days to death**:The date from when they were diagnosed, and they died (string)
-**Vital Status**: the survival status of the person (string)
-**Primary Diagnosis**:Their initial pathological diagnoses of cancer (string)
-**Ethnicity**: "An individual's self-identified social and cultural category, particularly whether they identify as Hispanic or Latino" (string)
-**Race**: "A taxonomic group that is a division of a species that is classified arbitrarily. It is characterized by shared heredity, physical attributes, and behavior, and in the case of humans, by common history, nationality, or geographic distribution" (string)


##Methods 

##Extract the Data from the cBioPortal 
The first dataset was downloaded from the cBioPortal site using the "download clinical data for the selected cases" button extracting all columns. 

The link to the dataset can be found [here.](https://www.cbioportal.org/study/clinicalData?id=prad_su2c_2015)

##Cleaning Our Data
The first dataset was downloaded as a TSV file which required conversion in Excel to a CSV file. After importing the data into Excel using the Import Data From Text tool, the worksheet was saved as a csv file. The raw data contained 150 rows and 20 columns. As a team we worked through the exploratory investigation and cleaning of the data by utilizing GitHub to collaborate on an R Markdown file. 

Please refer to our GitHub repository for the link to our csv data for the first dataset. It is labelled `diseaseddivadata`. 

```{r}
#Loaded the data as a CSV into the R Markdown file 
rawdat<- read.csv("~/Documents/Dartmouth/Fall 2021/QBS 181/group project/Data .csv")
```

To gain an understanding for the types of variables we would be analyzing along with some of the numeric summaries for the continuous variables, we employed the summary function. 

```{r pressure, echo=FALSE}
#Summarize the variables 
summary(rawdat)
```
Preliminary findings indicate, mean age of diagnosis for prostate cancer is approximately 67 years of age. Average tumor content found in these biopsies appears to be 60%. Initial analysis revealed that there were several cells for which NA values were present. The following command was used to eliminate the NAs saving the new data to a dataframe called complete_dat. 

```{r}
#Remove NAs
complete_dat <- na.omit(rawdat)
```

Upon removal of the NAs, the dataset reduced to 147 rows and 20 columns. Three patients from the original extract contained in rows 71 to 73 were therefore excluded from subsequent analyses due to the NAs being present in both the Diagnosis.Age column along with the Abiraterone (ABI) and Enzalutamide (ENZA) Exposure Status. These two columns are crucial in further analyses being as age is a related factor for severity of disease. Furthermore, without information as to prior exposure status to the androgen deprivation therapies, assessment of mCRPC is incomplete. 

Further analysis of the data revealed that several columns were found to have duplicated values. To assess whether the individual cases included in the sample were duplicated, we utilized the duplicated command to check the Sample ID column for repeat values. As shown below, none were found. 

```{r}
#Check for duplicates
duplicated(complete_dat$Sample.ID)
```
Upon cursory glance the Patient ID and Sample ID column appeared to be populated with the exact same values per each row. To confirm this assumption we used the following syntax to check if the values between the two columns were unique. The syntax reads as follows, from the compelete_dat dataframe check if Patient Id is not contained in Sample Id then output the results. 

```{r}
#Check if sample id is unique
complete_dat[!complete_dat$Patient.ID %in% complete_dat$Sample.ID, ]
```

The output above is empty indicating that all the Patient Ids are contained within the Sample Id. In other words the two columns are the same. 

Several columns appeared to be populated by the same value for each row. For example, the Cancer.Type column was entirely populated by the value "Prostate Adenocarcinoma".  To determine whether this assumption was indeed true we created the following function utilizing a for loop to cycle through each column to check that the values contained in the column were unique. 

```{r}
find_nonuniq <- function(dataset){ #defining the function 
  cols_nonunique <- c() #set an empty vector to contain the results of the function
  for(i in 1:ncol(dataset)){ #initiated the for loop to traverse all the columns
    if(length(unique(dataset[,i])) <= 1){ #if the output of the unique function showed 1 or fewer values add that column index to the vector 
      cols_nonunique[length(cols_nonunique) + 1] <- i #append the vector with the new columns 
    }
  }
  print(cols_nonunique) #print the vector 
} 
cols_nonunique <- find_nonuniq(complete_dat) #run the function on the complete_dat dataframe 

```
After, running this function the output indicated that 9 columns were found to contain the same repeated value for every row contained within that column. To verify that this was true we cross checked each column index against the "complete_dat" dataframe and found that indeed the values were repeated by row. We therefore removed each of those columns according to the index presented in the cols_nonunique output. 

```{r}
remove_nonuniques <- complete_dat[,-cols_nonunique] #removing the columns with repeated values 
```

Consquently, after removal of the data columns with repeated values we were left with the "remove_nonuniques" dataframe which contained 147 rows and 11 columns. 

##Bonus Aim 
The last aim checks for an association between diagnosis age and tumor site. According to the Cleveland Clinic 1 in 6 men will be diagnosed with prostate cancer during the course of their lifetime. Research from the American Cancer Society suggests that 6 out of 10 cases of prostate cancer are diagnosed among men 65 years or older. As mentioned previously the mean age of diagnosis among this prospective cohort was 67 years of age. Prior research suggests that as men get older their risk of being diagnosed with prostate cancer increases. In addition, the publication in Cell suggests that bone tumors are the most common site of metastatic disease. This aim therefore intends to determine whether these two prior notions hold true among the data in question. 

To conduct the analysis we subset the data columns Diagnosis.Age and Tumor.Site into a dataframe called age_tumor. The numeric index of these columns was 4 and 11 respectively. Before proceeding with any analysis we conducted an exploratory investigation to understand the quantity of unique tumor sites present in the data set along with the spread of age at diagnosis.  
```{R}
age_tumor <- remove_nonuniques[c(4,11)] #subset the data 
age_tumor
summary(unique(age_tumor$Tumor.Site)) #look at unique values for tumor.site 
```

According to the aforementioned summary and unique command, 20 unique tumor sites are present within this data. Next, we explored the distribution of diagnosis age to determine min, max, mean and median ages for this prospective prostate cohort. 

```{r}
summary(age_tumor$Diagnosis.Age)
```
Given the minimum age at diagnosis was 40 and the maximum age at diagnosis was 85 we needed to come up with a way to age-stratify the data in order to compare the various tumor sites with age at diagnosis. An article published in the [British Journal of Cancer](https://www.nature.com/articles/bjc2013268#Tab1) described a methodology for stratifying age within a population based study investigating prostate cancer. The researchers stratified age according to the following groups "40-59", "60-69", "70-79" and "80+ years". Since this was a validated study we employed the same age-stratified bins for our analysis. 

Using the `tidyverse` package we employed several `ifelse` statements to group the ages into the various aforementioned age strata. All values were grouped into their respective bins with the final clause indicating that values that did not fall into these specified ranges should be classified as `NA`. 

```{r}
library(tidyverse) 
#grouping the age by the BJC age-stratified bins using ifelse statements 
age_tumor$agegrp <- ifelse(age_tumor$Diagnosis.Age >= 40 & age_tumor$Diagnosis.Age <=59, "40-59",
                  ifelse(age_tumor$Diagnosis.Age > 59 & age_tumor$Diagnosis.Age <= 69, "60-69",
                         ifelse(age_tumor$Diagnosis.Age > 69 & age_tumor$Diagnosis.Age <= 79, "70-79",
                                ifelse(age_tumor$Diagnosis.Age >79,"80+", NA))))
```

After stratifying the data, we created a summary table utilizing the packages `dplyr` and `gtsummary` to assess the aggregated counts of tumors by site grouped by age. 

```{r}
library(dplyr) 
#install.packages("gtsummary") 
library(gtsummary)
age_tumor %>% 
  select(Tumor.Site, agegrp) %>%
  tbl_summary(by = agegrp, label = Tumor.Site ~ "Tumor Site") %>% #develop the table based on the selected input
  add_p(test=everything()~"kruskal.test") #test for the differences among ranks 
```
As evidenced by the output of the table, several of the aggregate counts of tumors by site were either 0 or 1 in most cases, which is not that significant. Five sites however did demonstrate counts greater than 1 and those include, Bone, Liver, Lymph Node, Prostate and Soft Tissue. To assess whether the differences among the age stratified ranks were significant by tumor site we conducted a Kruskal-Wallis Rank Sum Test. The output of which can be found in the last column of this table. The value of p was reported as 0.9 and assuming an alpha significance level of 0.05 this value is not significant. Thus, we conclude that there is no significant difference exhibited among the age stratified ranks by tumor site. 

We found the quantities of the aggregate counts for the following tumor sites: Bone, Liver, Lymph Node, Prostate and Soft Tissue to be interesting so we further subsetted the data to explore the distribution of tumors. Additionally, we wanted to further assess whether bone, as mentioned earlier, was indeed the site of greatest metastatic disease. 

To do this we grouped the data by age group and tumor site to create a count of tumors by age. Then we filtered for those cases for which the frequency of tumors was greater than 1. Using the `ggplot2` package we created a clustered bar plot to compare the distribution of those five tumors by age group. The graph was formatted with the `viridis` package to create the color scheme displayed below. Axes labels and legend titles were added as appropriate. 

```{r}
#calculate the frequency of tumors by age group 
freq <- age_tumor %>% group_by(agegrp,Tumor.Site) %>% summarise(Freq=n())
freq <- rename(freq, "Count of Tumors"=Freq) 
freq_gt1 <-freq[which(freq$`Count of Tumors`>1),] #subset the data to include the five columns of interest 
library(ggplot2) 
library(viridis) 
#create a bar chart of the data 
ggplot(freq_gt1, aes(agegrp,`Count of Tumors`)) +
  labs(x="Age Grouped by BJC paper levels", y="Frequency of Tumors") +
  geom_bar(aes(fill=`Tumor.Site`),stat="identity",position="dodge") +
  scale_fill_viridis_d(option  = "mako") 
```

Curiously enough, bone was not the most common site of metastatic disease among this prospective prostate cohort. In fact, the lymph nodes were shown to have a greater quantity of tumors amounting to 61 tumors across the entire cohort as opposed to 43 among bone. Here from this graph we can also see that the "60-69" and "70-79" groups experience the most tumors proportionally, as would  be expected given that as men age the likelihood of developing prostate cancer increases. If time permitted we would have further calculated the incident rate ratios per age group for the five tumor sites where frequency was greater than 1 to understand the proportional burden of disease experienced by each age group. 

Overall, this aim confirms that as men age incidence of prostate cancer increases with metastasis of disease occurring more frequently in the lymph nodes and bone. This data was limited given that the population was a bit skewed toward the older age groups (60-79) with very few cases representing those older than 80. More information as to prognosis and vital status beyond age 80 would be beneficial in determining whether the assumption of age and incidence is valid. 


##Extract the Data from National Cancer Institute 
We downloaded the second cancer dataset from the National Cancer Institute GDC Data Portal for all the clinical cases including all the columns. 

The link can be found [here.](https://portal.gdc.cancer.gov/exploration?cases_size=100&filters=%7B%22op%22%3A%22and%22%2C%22content%22%3A%5B%7B%22op%22%3A%22in%22%2C%22content%22%3A%7B%22field%22%3A%22cases.primary_site%22%2C%22value%22%3A%5B%22prostate%20gland%22%5D%7D%7D%2C%7B%22content%22%3A%7B%22field%22%3A%22cases.project.project_id%22%2C%22value%22%3A%5B%22TCGA-PRAD%22%5D%7D%2C%22op%22%3A%22in%22%7D%2C%7B%22content%22%3A%7B%22field%22%3A%22genes.is_cancer_gene_census%22%2C%22value%22%3A%5B%22true%22%5D%7D%2C%22op%22%3A%22in%22%7D%5D%7D&searchTableTab=cases)

##Excel Cleaning for Second Data Set 
The GDC portal website provided both a cleaned and uncleaned version of their prostrate cancer data. The cleaned data mirrors what can be found on their visualization dashboard describing 493 patients with 24 data points while the uncleaned  version contains many more clinical parameters such as clinical stages of the tumor, days to last follow up, and treatment. Both GDC datasets are more robust in their capture of the clinical parameters related to prostate cancer in contrast with the cBioPortal data previously analyzed. This indicates that since 2015 when the Cell paper was published, the observation and recording of tumor data related to prostrate cancer has significantly increased allowing researchers to provide more insight into the manifestation of disease. For this portion of our analysis we downloaded both datasets as we were interested in wrangling the data and discerning the overlap between the two datasets. We first started by cleaning the clinical data set with the abundance of parameters.   

The data was downloaded as a TSV file so it needed to be imported into Excel to change the format to a CSV or .XLSX file. The raw data contained  960 rows and 156 columns. Upon further investigation it was evident that several of the columns were empty or had values missing. In order to determine the columns with no data present along with those which had missing values we used the Filter tool in Excel. Missing values were those marked as '-- in the cells. We developed a key for the missing values called "Key for Missing Values Columns". 

Based on the assessment where we developed the key of the missing values we determined that the raw data contained 112 empty columns for which no data was available and 33 columns with missing values. The 112 empty columns were then removed from the analysis by simple deletion in Excel and a new sheet was created, "Sample". This new sheet "Sample" contained 44 columns. 

Further investigation of the new "Sample" data indicated that some rows were shifted over particularly rows 141, 142, 206, 207, 284, 285, 494 and 495. We pinpointed the origin of the shift for the aforementioned rows to column Y. In order to account for this shift we copied the data from the "Sample" worksheet to a new sheet called "Sample Revised". Here we inserted a cell in column Y for each of the aforementioned rows to shift the values of the cells to the the right so that the cells would be associated with the correct column. 

Similarly the "treatment_type" column values were shifted to the right but also broken up into values of "Radiation Therapy/Pharmaceutical Therapy" and "NOS". To fix this issue we concatenated the values for the therapy and NOS in a new column, column AS. We then named this column "treatment_type".

After concatenating the values we copied the data from "Sample Revised" to a new worksheet called "cleaned_sample". In this dataset we noticed that after shifting the rows five columns were shown to be empty. Thus we removed the five columns: secondary_gleason_grade, synchronous_malignancy, tumor_grade, year_of_diagnosis and treatment_or_therapy.  We exported this data as a CSV file to then continue our analysis of the missing values in R.

For our final Excel file with the metadata and the various sheets please refer to our GitHub repository. You will find the .xlsx file under the title `clinical data from NCI`. 

##Missing Value Pipeline 
The following flowchart details the "Missing Value Pipeline" which outlines the sequence of steps taken to address the missing values present in the "uncleaned" version of the GDC portal data. Some of the steps have been previously discussed as they were done as part of the cleaning of the dataset in Excel. The remainder relating to "R" will be discussed in further detail below. 

```{r img-with-knitr, echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics("~/Downloads/MissingValueFlowchart.png")
```
##Dealing with Missing Values 
As mentioned previously, the GDC portal "uncleaned" dataset contained 33 columns with missing values. To be able to adequately analyze the data we need to deal with these missing value strings. First we began by exporting our cleaned data sample as a csv file from Excel. Then subsequently we imported the data into R. 

```{r}
sample <- read.csv("cleanedsample.csv")
```

Next, we recoded the string values representative of missing values to NAs using a custom function that searched for each value of '-- and replaced it with `NA`. The function was applied to the sample dataset imported above and saved to a new dataframe called `temp.NA`. 

```{r}
#changing '-- Null values to NA 
string_NA <- function(data){
data[data == "'--"] <- NA
return(data)
}

temp.NA <- string_NA(sample)
```
A cursory scan revealed that the strings were indeed changed to NA values within the dataset. However it was apparent that across several rows there were `NA` values present concurrently across various columns. To address this issue we therefore subsetted the data conditionally using the subset function based on whether `NA` values were present simultaneously across all three of the following columns:`classification of tumor`, `last known disease status`and `tumor largest dimension diameter`. 

```{r}
#subsetting data to remove specific rows 
temp.NA1 <- subset(temp.NA, temp.NA$classification_of_tumor != "NA" & temp.NA$last_known_disease_status !="NA" & temp.NA$tumor_largest_dimension_diameter!="NA")
dim(temp.NA)
dim(temp.NA1)
```
BY subsetting the rows from the `temp.NA` dataframe we removed 26 rows in which `NA` values were present across the three afroementioned columns. The `NA` values that are now left are column dependent rather than case dependent. Several `NA` values still remain however simply removing the columns is not effective given that those values that are populated within the column are important. For instance the majority of the `days to death` column is populated with `NA` values however lines 131 and 132 have the value `146` for the days of death. This is important information in determining how many days elapsed between diagnosis and death. 

To further visually explore the relationship between the missing variables and their respective CaseIDs we created a matrixplot using the package `VIM`. This graph shows black and white variables indicating the values present in each column followed by red demarcations indicating the missing variables. Notice the three red columns highlighted here. They correspond to `days to death`, `year of death`, and `treatment type`. Many columns towards the middle of the graph also seem to highlight several missing values. Those columns correspond to ratings for the clinical cancer stage of tumors, regional nodes and metastases. As demonstrated by this graph those three columns `days to death`, `year of death`, and `treatment type` uniformly are shown to have missing values however the clinical cancer stage columns intermittently illustrate missing values relative to each respective CaseID. 

```{r}
library(VIM)
matrixplot(temp.NA1,sortby=1)
```
We further investigated how one of the columns illustrated above with the missing values compared to CaseID. Using the `VIM` package again we created a margin plot to observe how the missing values in `days to last folluw up` (column 20) compared with each case. As depicted below, the column had 16 missing values with a fairly random scatter for the observed values shown in blue. The red values however seem to be concentrated towards the earlier and latter cases with the distribution being skewed for the red boxplot, in contrast to the blue boxplot for CaseID.  

```{r}
marginplot(temp.NA1[,c(1,20)])
```
## Natural Language Processing
The opportunities to employ natural language processing (NLP) in this dataset were limited, but the principles and tools of NLP were utilized to extract more information from the data. The second data, the GDC portal clinical data, had four columns corresponding to the AJCC staging classification of each patient in the data set. To help better understand what these classifications meant, we added a new column that included a written description of each of the AJCC staging classifications provided. To do this, we used Regex to identify AJCC stage patterns to match them to their written description. The written descriptions of each stage come from this [webpage.](https://www.cancer.org/cancer/prostate-cancer/detection-diagnosis-staging/staging.html) 

In order to analyze the data with the NLP principles we used the package `stringr`. First we subsetted the data into the four relevant columns, `ajcc_clinical_m`, `ajcc_clinical_t`, `ajcc_pathologic_n`, and `ajcc_pathologic_t`. This was saved to the dataframe `ajcc cols`. Each column corresponds to a clinical assessment of a particular site in relation to the clinical stage of cancer or prognosis.`ajcc_clinical_m` relates to the extent of the distant metastases for the cancer while  `ajcc_clinical_t` relates to the extent of the primary cancer.  `ajcc_pathologic_n` describes the stage of the cancer based on the nodes and `ajcc_pathologic_t` describes the stage of the cancer based on the primary tumor. 

```{r}
library(stringr)
staging_dat <- sample
ajcc_cols <- staging_dat %>% select(c("ajcc_clinical_m", "ajcc_clinical_t", "ajcc_pathologic_n", "ajcc_pathologic_t"))
```

Next we combined the four aforementioned classifier columns into one string. We removed mention of the string placeholder, '--,  used to indicate missing values by employing the `str_remove` function. This caused some of combined strings to only contain three values rather than four.  

```{r}
#Combine classifiers into one string
ajcc_cols$combined <- str_c(ajcc_cols$ajcc_clinical_m, ajcc_cols$ajcc_clinical_t, ajcc_cols$ajcc_pathologic_n, ajcc_cols$ajcc_pathologic_t, sep = " ")

#Take out effective NAs
ajcc_cols$combined <- str_remove(ajcc_cols$combined, "('--)++")
```

After combining the strings we created a vector of the `classificiations` as described in the AJCC staging classifications website link provided above. Each classification accounts for how the cancer was presented in the lymph nodes or elsewhere in the body. These values `N0` and `M1` shown in the descriptions below are available in our dataset from the `ajcc_clinical_m` and the `ajcc_pathologic_n` columns.

```{r}
#Classification descriptions (from website given above)
classifications = c("The cancer has not spread to nearby lymph nodes or elsewhere in the body. The Grade Group is 1 , and the PSA level is less than 10.",
                  "The cancer has not spread to nearby lymph nodes [N0] or elsewhere in the body [M0]. The Grade Group is 1. The PSA level is at least 10 but less than 20.",
                  "The cancer has not spread to nearby lymph nodes [N0] or elsewhere in the body [M0]. The Grade Group is 2. The PSA level is less than 20.",
                  "It has not spread to nearby lymph nodes [N0] or elsewhere in the body [M0]. The Grade Group is 1 to 4, and the PSA can be any value.",
                  " The cancer has spread to nearby lymph nodes [N1] but has not spread elsewhere in the body [M0]. The Grade Group can be any value, and the PSA can be any value.",
                  "It has spread to other parts of the body, such as distant lymph nodes, bones, or other organs [M1]. The Grade Group can be any value, and the PSA can be any value.",
                  "Not classified")
```

We then created a vector of the classifications for the clinical and pathologic information contained in our dataset that corresponded to each unique classification given above. 

```{r}
#Patterns to identify classification from AJCC info
regs = c("M0.T[0|2a].*N0", "M0.T[12][abc].*N0", "M0.T[12].N0", "M0.T[34].N0", "M0.T.*N1", "M1.T.*N.*", ".*")
```

Next, we grouped the data according to each of the numeric classifications assigned in the previous step. To do this we used the `which` function along with the `grepl` function to find the position or index for which the classification of interest was true.  For example, the first group `M0.T[0|2a].*N0` defined in the `regs` vector above, was used to classify 222 of the individuals. The logical positions from the `ajcc cols` combined data for the first five individuals were 1,2,13,14,15. 

```{r}
#Label row indices with groups
group1psa10 <- which(grepl(regs[1], ajcc_cols$combined))
group1psa20 <- which(grepl(regs[2], ajcc_cols$combined))
group2psa20 <- which(grepl(regs[3], ajcc_cols$combined))
groups14 <- which(grepl(regs[4], ajcc_cols$combined))
nodegroup <- which(grepl(regs[5], ajcc_cols$combined))
metastizedgroup <- which(grepl(regs[6], ajcc_cols$combined))
nogroup <- which(grepl(regs[7], ajcc_cols$combined))
```

Once grouping of the data based on the numeric classifications was complete we merged the text description of the AJCC clinical stage from `classifications` with the `ajcc cols` dataframe. This added a sentence description that interpreted the numeric clinical stage. In the output below notice how the sentences are structured. 

```{r}
#Create a column containing group description
ajcc_cols$AJCC_Stage_Description <- ajcc_cols$combined

ajcc_cols$AJCC_Stage_Description[nogroup] <- classifications[7]
ajcc_cols$AJCC_Stage_Description[metastizedgroup] <- classifications[6]
ajcc_cols$AJCC_Stage_Description[nodegroup] <- classifications[5]
ajcc_cols$AJCC_Stage_Description[groups14] <- classifications[4]
ajcc_cols$AJCC_Stage_Description[group2psa20] <- classifications[3]
ajcc_cols$AJCC_Stage_Description[group1psa20] <- classifications[2]
ajcc_cols$AJCC_Stage_Description[group1psa10] <- classifications[1]

#Lets view the first 6 classification descriptions.
head(ajcc_cols$AJCC_Stage_Description)

#Add this column to rest of data
staging_dat$AJCC_Stage_Description <- ajcc_cols$AJCC_Stage_Description
```
This type of NLP processing methodology described above is very useful in automating the translation of exome and transcriptome numeric sequencing of the cancer genes into something digestible for the general public. Very few people understand what `M0` means with regards to a prognosis of prostrate cancer disease. As evidenced by this analysis, `M0` indicates that the cancer had no spread elsewhere in body. Practical applications of this particular NLP methodology may include sharing sequencing results with affected individuals through a patient portal, informing the care team of results through the electronic medical record or automating documentation. 

##Relational Data 
With the data for the GDC portal clinical dataset cleaned, we wanted to compare apples to apples and determine just how different our newly cleaned clinical dataset was from the already clean website version. The following diagram illustrates how the clinical dataset is interconnected with the already clean version from the website. Highlighted below it is apparent that four of the columns present in the clinical dataset serve as foreign keys for the cleaned dataset. These columns include `case submitter id`, `ethnicity`, `race`, and `vital status`. We will utilize this relationship to join the data in subsequent steps. 

```{r img-with-knitr, echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics("~/Downloads/RelationalDataDiagram.png")
```

##SQL to JOIN and APPEND DATA 
Althought the two datasets do share similarities one stark difference was the number of observations contained in each. The clinical dataset cleaned by the DiseaseDivas contained nearly 960 observations while the cleaned version taken directly from the GDC portal website only contained 493. `What might be contributing to this discrepancy?`

After sorting the data by `Case Submitter ID`, we learned that several of the `case submitter Id's` in the cleaned clinical dataset were duplicates due to columns AJ and AN corresponding to `treatment outcome` and `treatment type`. For our analysis treatment outcome and treatment type were not relevant. Thus, to account for this discrepancy in the data observations we copied the data from the `cleaned sample` sheet in Excel and created a new sheet called `removed dups`. In this sheet we removed the columns that contained the split version of the therapy and NOS which corresponded to columns AK-AN. Additionally we removed columns AJ and AN then proceeded to use the `Remove Duplicates` tool in Excel. 

Once this cleaning in Excel was complete we were left with 493 observations of 39 variables for the clinical dataset. The lengths of the two datasets therefore aligned. To confirm that this was indeed true we imported the data into R and compared both datasets using the `dim` function. 

```{r}
new_sample <- read.csv("removed_dups.csv") #clinical data 
new_sample <- subset(new_sample, select=-c(36:39))
dim(new_sample)
GDC <- read.csv("Dataset2DD.csv") #cleaned data from GDC portal
GDC <- rename(GDC, case_id=Case.UUID)
dim(GDC)
```
The clinical data that we cleaned was loaded into R as `new sample`. The columns which we had removed in Excel,AJ-AN, unfortunately still appeared but with `NA` values contained in each row. We removed these columns using the subset function. The clinical dataset then contained 493 observations of 35 data points while the cleaned data contained 493 observations of 24 data points. The lengths match! 

After confirmation that the lengths of the two datasets matched we began to conduct our SQL relational data comparative analysis. Ultimately the goal of this analysis was to relate findings across the cBioPortal data against the GDC portal data. Although the variables greatly differed between the two data sources two things that both datasets did have in common were the `Diagnosis Age` and the `Prior Treatment`. We therefore decided to group the diagnosis age by the age stratified bins previously used as per the BJC paper. 

We started with the first dataset utilizing the dataframe `remove nonuniques` for which the repeat values had been removed. Next we renamed the `Patient Id` and the `Diagnosis Age` column so that they were easier to call in the SQL syntax. Using the `sqldf` package we subsetted just the `Patient Id` and the `Diagnosis Age` and  employed a `case when` statement similar to an ifelse statement in R to group the ages by their respective bins.This was saved to the dataframe `dataset 1 sql`. The name given to this newly created age group column was the case when statement therefore we changed the name to `agegrp` using the `names` function.  We then appended this data in `dataset 1 sql`  to the original dataframe using the `JOIN` syntax. This appended version of the data was saved to `join data1 sql`. To ensure that the ages did indeed match the new groupings we selected the `Age` column and the `agegrp` column and conducted a quick investigation utilizing the `head` function. Voila! As the output demonstrates, the age stratification in SQL was indeed successful. 

```{r}
#install.packages("sqldf")
library(sqldf)
dataset_1 <- remove_nonuniques
dataset_1 <- rename(dataset_1, ID=Patient.ID)
dataset_1 <- rename(dataset_1,Age=Diagnosis.Age)
dataset_1sql <- sqldf("SELECT ID, case when Age >=40 and Age <= 59 then '40-59' when Age >59 and Age <= 69 then '60-69'when Age >69 and Age <= 79 then '70-79' else '80+' end  FROM dataset_1 GROUP BY ID,
                      case when Age >=40 and Age <= 59 then '40-59' when 
                      Age >59 and Age <= 69 then '60-69'when
                      Age >69 and Age <= 79 then '70-79' 
                      else '80+' end")
names(dataset_1sql)[2]<-"agegrp"
join_data1_sql <- sqldf("SELECT * FROM dataset_1 JOIN dataset_1sql on dataset_1.ID=dataset_1sql.ID")

#age check 
age_ds1 <- select(join_data1_sql,"Age","agegrp")
head(age_ds1)
```

With the first data source formatting complete we then moved on to the second data source, the GDC portal data. Here a few more steps were employed given that we had to join the clinical dataset to the cleaned website version of the data in order to compare it as a whole to the cBioPortal data. Thus, we first joined the clinical dataset to the cleaned website data based on the foreign key for the `Case Id`. The combination of the two datasets produced a large dataset of 493 observations with 59 data points. 

```{r}
joined_data <- sqldf("SELECT * FROM new_sample JOIN GDC on new_sample.case_id=GDC.case_id")
dim(joined_data)
```
Fifty-nine data points is A LOT of data. Before proceeding with our SQL additions we perused this new data sample. We noticed many columns for which the same value was contained within every row of the column so we employed the same `find nonuniques` custom function from our earlier cleaning of cBioPortal to remove the columns where the data was repeated. 

```{r}
repeat_cols <- find_nonuniq(joined_data)
remove_dups <- joined_data[,-repeat_cols]
dim(remove_dups)
```
From 59 columns we then reduced to 54 columns. Still yet we had duplicate columns present in the data but of a different kind. These columns were the foreign keys present in the two datsets: `case submitter id`, `ethnicity`, `race`, and `vital status`. To account for this duplication we employed the use of a new custom function called `carbon copy`. This function looks through the dataframe and removes the columns that are duplicates of each other. It employs base R syntax using the `!` to facilitate the match. 

```{r}
carbon.copy <- function(df){
  return(df[!duplicated(as.list(df))])
}

new_updatedremovedups <- carbon.copy(remove_dups)
dim(new_updatedremovedups)
```
After employing the use of the `carbon copy` function we were left with 45 columns in the new dataframe `new updated remove dups`. Investigation of the data confirms that the duplicate foreign keys were indeed removed from the second half the data, from columns 33 onwards in `removed dups`. The first occurrence of the foreign key still remains so no information was lost as part of this function. 

Before we could add the age group stratification we needed to perform a bit of natural language processing, specifically text mining. `Age at Diagnosis` as per the cleaned website version of the GDC portal data was presented as a `character` or string value, `63 years 262 days`. In order for us to be able to use this data to create our age stratification we needed to extract the 2 numeric digits at the beginning of the string relating to age in years. To do this we used the `substr` function which extracts substrings in a character vector. We set the `start` argument as the first position and the `stop` argument as the second position in order to capture the two digits necessary. Then, we merged this vector using the `cbind` function to the `new updated remove dups` dataframe. Unfortunately the value was still saved as a character so we had to change the format of the variable to numeric using the `as.numeric` function. Some `NA` values were introduced as part of this function which were applicable given that the data for `Age at Diagnosis` was missing in those cases. 

```{r}
z <- substr(new_updatedremovedups$Age.at.diagnosis, 1,2)
head(z)
new_updatedremovedups$Age <- cbind(z)
new_updatedremovedups$Age <- as.numeric(new_updatedremovedups$Age)
```
Lastly, we performed the age stratification. In order to run the SQL syntax as done previously we renamed the `Case ID` column to `ID` for ease of use in the arguments. We employed the same methodology as before using `case when` statements to group the ages by the BJC paper age bins. Finally we merged the data from the subset for age stratification to the combined GDC `dataset 2`. 

```{r}
new_updatedremovedups <- rename(new_updatedremovedups, ID=case_id)
dataset_2 <- new_updatedremovedups
dataset_2sql <- sqldf("SELECT ID, case when Age >=40 and Age <= 59 then '40-59' when Age >59 and Age <= 69 then '60-69'when Age >69 and Age <= 79 then '70-79' else '80+' end  FROM dataset_2 GROUP BY ID,
                      case when Age >=40 and Age <= 59 then '40-59' when 
                      Age >59 and Age <= 69 then '60-69'when
                      Age >69 and Age <= 79 then '70-79' 
                      else '80+' end")
names(dataset_2sql)[2]<-"agegrp"
join_data2_sql <- sqldf("SELECT * FROM dataset_2 JOIN dataset_2sql ON dataset_2.ID=dataset_2sql.ID")
```

At this point both the cBioPortal and GDC datasets have been outfitted with age stratified bins facilitating greater analysis of the clinical parameters in relation to age. Furthermore the clinical dataset along with the website version of the GDC data have been merged to create one cohesive dataset. This relational data comparative analysis provides great insight into the discrepancies apparent in the data and the similarities exhibited by the datasets. In addition the methods employed can aid in subsequent research down the line in comparing each dataset to each other to garner insights into the burden and progression of metastatic prostate cancer. 

##Dashboard 
Lastly, we couldn't let our beautiful analyses go to waste so we created a simple dashboard in Excel of some of our more notable and significant graphs from this prostate cancer analysis. 

```{r img-with-knitr, echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics("~/Downloads/Dashboard.png")
```



